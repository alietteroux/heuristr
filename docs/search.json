[{"path":"https://alietteroux.github.io/heuristr/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Aliette Roux. Author, maintainer.","code":""},{"path":"https://alietteroux.github.io/heuristr/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Roux (2023). heuristr: make easier quantitative analysis Heurist databases. https://github.com/alietteroux/heuristr, https://alietteroux.github.io/heuristr/.","code":"@Manual{,   title = {heuristr: To make easier quantitative analysis from Heurist databases},   author = {Aliette Roux},   year = {2023},   note = {https://github.com/alietteroux/heuristr, https://alietteroux.github.io/heuristr/}, }"},{"path":"https://alietteroux.github.io/heuristr/index.html","id":"heuristr","dir":"","previous_headings":"","what":"To make easier quantitative analysis from Heurist databases","title":"To make easier quantitative analysis from Heurist databases","text":"heuristr aims make easier quantitative analysis Heurist databases.","code":""},{"path":"https://alietteroux.github.io/heuristr/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"To make easier quantitative analysis from Heurist databases","text":"can install development version heuristr GitHub :","code":"# install.packages(\"devtools\") devtools::install_github(\"alietteroux/heuristr\")"},{"path":"https://alietteroux.github.io/heuristr/index.html","id":"before-using-heuristr--export-xml-files-from-heurist","dir":"","previous_headings":"","what":"Before using heuristr : export XML files from Heurist","title":"To make easier quantitative analysis from Heurist databases","text":"hr_import() reads XML files exported Heurist. use , two XML files must first exported Heurist : XML file including data (fields’values entered database) : XML file can exported Heurist via Publish menu > Export > XML (recommended option). careful : records selected Heurist session export, data theses selected records exported. XML file exported Heurist describing database structure (vocabularies, fields’caracteristics…) : XML file can exported Heurist via Design menu > Download > Structure (XML).","code":""},{"path":"https://alietteroux.github.io/heuristr/index.html","id":"example-database-and-data-files","dir":"","previous_headings":"","what":"Example database and data files","title":"To make easier quantitative analysis from Heurist databases","text":"’ve created fictitious Heurist database, named “aliet_test_R”, viewable https://heurist.huma-num.fr/heurist/?db=aliet_test_R&website database, ’ve exported two XML files : look folder “documents/data_example” Github repository, directly download files .","code":""},{"path":"https://alietteroux.github.io/heuristr/index.html","id":"read-data-and-paradata-from-heurist-database-with-hr_import-function","dir":"","previous_headings":"","what":"Read data and paradata from Heurist database, with hr_import() function","title":"To make easier quantitative analysis from Heurist databases","text":"function returns several dataframes Environment : Heurist ‘record type’ dataframe : dataframes, row matches Heurist ‘record’ dataframe named “z.h.tables.fields” : row describes field used Heurist ‘record type’ (type, help text, requirement, repeatability…) dataframe named “z.h.vocabularies” : row matches term used Heurist vocabulary ; term joined level (ranking position vocabulary) attached parents’terms hr_import() returns error messages ’ll try , please contact us. example Heurist database (named “aliet_test_R”), ’ve obtained 8 dataframes :  hr_import() taken long time, remember can save objects environment folder, open afterwards (see , last part page). ’re interested function code : hr_import() reads XML files , actually, function script uses readLines() read . Indeed, seems R slow parse XML files, yet XML Heurist files can big ! Therefore, code may seem convoluted, using regular expressions different functions recover XML structure. Note previously, proposed solution using xml2 library, retrievable folder “documents” Github repository. give slow… Thereafter, ’ll manage data using tidyr ggplot2 ; ’ll display tables knitr::kable().","code":"library(heuristr)  hr_import(data.file=\"documents/data_example/aliet_test_R_data.xml\",           structure.file=\"documents/data_example/aliet_test_R_structure.xml\") #> We're importing data and structure files (most time-consuming step)... Thank you for waiting... #> Data and structure files have been successfully imported. Now we're selecting and managing data... Thank you for waiting... #> We've finished. It's ready to use ! #> Import has required 6.91 secs library(tidyverse) library(knitr)"},{"path":"https://alietteroux.github.io/heuristr/index.html","id":"about-columns-names-and-formats","dir":"","previous_headings":"","what":"About columns names and formats","title":"To make easier quantitative analysis from Heurist databases","text":"Let’s look dataframe Personne (6 rows 24 columns) : Rows ordered according column starting “z.h.id.”. numbers match records IDs automatically created Heurist ; depend date added. look column names formats : Note : dataframe contains “paradata” fields : fields starting “z.h.”. column starting “z.h.title” corresponds “Heurist title masks”. Colnames “display fields names” Heurist forms (database fields names). Therefore, columns may name : ’s possible contributor renamed existing field name already present database (like “Nom” example). cases, hr_import() automatically adds position number names (see Nom_1 Nom_2 example). Temporal, spatial file fields declined several columns : see , part “Dealing temporal, spatial file fields”. columns character, except : paradata fields (z.h.visibility,z.h.visnote,z.h.workgroup,z.h.workgroup.id) : factor fields type “enum” “relationtype” (see column field.type dataframe z.h.tables.fields) “repeatable” (see column field.MaxValues dataframe z.h.tables.fields) : factor (like Sexe example) fields ending “.temporal.type”, describing records values spatial fields : factor fields type “float” (see column field.type dataframe z.h.tables.fields) “repeatable” (see column field.MaxValues dataframe z.h.tables.fields) : numeric (like Nombre de publications example). , ’re abble know levels “enum” fields ; perform arithmetic “float” fields :","code":"Personne %>% kable() data.frame(colname=names(Personne),            format=as.character(sapply(Personne, class))) %>%   kable() levels(Personne$Sexe) #> [1] \"Female\" \"Male\" summary(Personne$`Nombre de publications`) #>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #>    8.00   15.25   17.50   17.67   19.75   28.00"},{"path":"https://alietteroux.github.io/heuristr/index.html","id":"dealing-with-repeatable-fields-multiple-values-in-a-field-for-one-record","dir":"","previous_headings":"","what":"Dealing with “repeatable” fields (multiple values in a field for one record)","title":"To make easier quantitative analysis from Heurist databases","text":"“Repetable” fields match value equal 1 column field.MaxValues dataframe z.h.tables.fields. Let’s look “repeatable” fields tables Laboratoire,Objet Personne : column Discipline(s) table Laboratoire appears “repeatable” field, look records : Usign hr_import(), different values “repeatable” field one record separated ” // “. can count records two different ways : looking combinations terms (see option ) ; looking terms (see option B ) : case, use separate_rows() function tidyr. also use separate_rows() ’d like know objects discovered different researchers (table Personne.Objet). , ’re abble count discovered objects per researcher.","code":"z.h.tables.fields %>%   filter(table.name %in% c(\"Laboratoire\",\"Objet\",\"Personne\") &            field.MaxValues!=1) %>%   select(table.name,field.DisplayName,field.type) %>%   kable() Laboratoire %>%    select(z.h.title.Laboratoire,`Discipline(s)`) %>%   kable() # Option A Laboratoire %>%    count(`Discipline(s)`) %>%   kable() # Option B Laboratoire %>%    separate_rows(`Discipline(s)`,sep= \" // \") %>%   count(`Discipline(s)`) %>%   kable() Objet %>% select(z.h.id.Objet,`Découvreur(s)`) %>%   kable() Personne.Objet <- Personne %>%    select(z.h.id.Personne,z.h.title.Personne) %>%   left_join(Objet %>%               select(z.h.id.Objet,`Découvreur(s)`) %>%               separate_rows(`Découvreur(s)`,sep=\" // \"),             by=c(\"z.h.id.Personne\"=\"Découvreur(s)\")) Personne.Objet %>% kable() Personne.Objet %>% group_by(z.h.title.Personne) %>%   summarise(nb.objets=sum(!is.na(z.h.id.Objet))) %>%   arrange(desc(nb.objets)) %>%   kable()"},{"path":"https://alietteroux.github.io/heuristr/index.html","id":"gathering-terms-in-a-vocabulary","dir":"","previous_headings":"","what":"Gathering terms in a vocabulary","title":"To make easier quantitative analysis from Heurist databases","text":"“Terms list” fields match value “enum” column field.type dataframe z.h.tables.fields. look informed fields (empty fields), select fields matching value “empty” column field.empty z.h.tables.fields. column Type d’objet table Objet appears “terms list” field, count records per term : Actually, terms nested. look vocabulary structure (“tree”), select rows z.h.vocabularies field.JsonTermIDTree one field “Type d’objet” described z.h.tables.fields. see vocabulary named “Type d’objets vocab” (see column Level1) composed 4 levels (see column maxLevel). following lines, gather terms “Level3”, “Level2”.","code":"z.h.tables.fields %>%   filter(field.type==\"enum\" & field.empty==\"no empty\") %>%   select(table.name,field.DisplayName,field.type) %>%   kable() Objet %>% count(`Type d'objet`) %>%   kable() voc <- z.h.vocabularies %>%    semi_join(z.h.tables.fields %>%                filter(field.DisplayName==\"Type d'objet\"),             by=\"field.JsonTermIDTree\")  voc %>% kable() # Gathering to \"Level 3\" Objet %>% count(`Type d'objet`) %>%   left_join(voc,by=c(\"Type d'objet\"=\"trm_Label\")) %>%   group_by(Level3) %>% summarise(nb=sum(n)) %>%   kable() # Gathering to \"Level 2\" Objet %>% count(`Type d'objet`) %>%   left_join(voc,by=c(\"Type d'objet\"=\"trm_Label\")) %>%   group_by(Level2) %>% summarise(nb=sum(n)) %>%   kable()"},{"path":[]},{"path":"https://alietteroux.github.io/heuristr/index.html","id":"relationship-marker-fields","dir":"","previous_headings":"Dealing with “Record relationship”","what":"“Relationship marker” fields","title":"To make easier quantitative analysis from Heurist databases","text":"“Relationship marker” fields match value “relmarker” column field.type dataframe z.h.tables.fields. Let’s look “relation markers” used database : see contributor created 2 “relationship marker” fields “Personne” : usage recommended may create problems viewing records Heurist. ’s recommended, exist ! XML data file, values “relationship marker” fields informed “relationship” : can recover table belongs , can’t recover field belongs (2 “relationship marker” fields created “record type”). Therefore, hr_import() function automatically creates one unique “relationship marker” field table : field match column finishing “.relationship”. Let’s look dataframe Personne :","code":"z.h.tables.fields %>%   filter(field.type==\"relmarker\") %>%   select(table.name,field.DisplayName,field.type) %>%   kable() names(Personne) #>  [1] \"z.h.id.Personne\"                   \"z.h.title.Personne\"                #>  [3] \"Nom_1\"                             \"Prénom\"                            #>  [5] \"Sexe\"                              \"Date de naissance.temporal.raw\"    #>  [7] \"Date de naissance.temporal.type\"   \"Date de naissance.DAT.raw\"         #>  [9] \"Date de naissance.DAT.year\"        \"Date de naissance.DAT.month\"       #> [11] \"Date de naissance.DAT.day\"         \"Date de naissance.property.DET\"    #> [13] \"Lieu de naissance.geo.type\"        \"Lieu de naissance.geo.wkt\"         #> [15] \"Nombre de publications\"            \"Nom_2\"                             #> [17] \"Carrière & Parentèle.relationship\" \"z.h.added\"                         #> [19] \"z.h.citeAs\"                        \"z.h.modified\"                      #> [21] \"z.h.workgroup\"                     \"z.h.visibility\"                    #> [23] \"z.h.visnote\"                       \"z.h.workgroup.id\""},{"path":"https://alietteroux.github.io/heuristr/index.html","id":"relation-vocabularies","dir":"","previous_headings":"Dealing with “Record relationship”","what":"“Relation” vocabularies","title":"To make easier quantitative analysis from Heurist databases","text":"“Relationship marker” fields necessarily use vocabulary. vocabularies match value “relation” column trm_Domain dataframe z.h.vocabularies. Let’s look different vocabularies (Level1) used “relationship marker” fields : relationships Family","code":"z.h.vocabularies %>%    filter(trm_Domain==\"relation\") %>%   distinct(Level1) %>%   kable()"},{"path":"https://alietteroux.github.io/heuristr/index.html","id":"record-relationship-dataframe","dir":"","previous_headings":"Dealing with “Record relationship”","what":"“Record relationship” dataframe","title":"To make easier quantitative analysis from Heurist databases","text":"contributor informs “relationship” via “relationship marker” Heurist, inverse relation automatically created Heurist reports. XML data file, seems can recover recorded relations (inverses). hr_import() function duplicates relationship original table : relationship B, hr_import() automatically creates relationship B . “Original” relationships “created” inverses can distinguished column z.h.original dataframe Record relationship. , want uniquely treat “original” relationships, can filter records column. Let’s look relationship records regarding family links (Level1==“4. Family”). see contributor informed “id-60 IsSonOf id-47” ; hr_import() function automatically created opposite (“id_47 IsParentOf id-60”), using inverse terms retrievable z.h.vocabularies. Let’s look relationships regarding “id-47” person : obtain 3 relationships : matches content “relmarker” field dataframe Personne (column Carrière & Parentèle.relationship). Please note : previous example, ’ve used column z.h.id.Personne dataframe Personne, column Carrière & Parentèle.relationship dataframe Personne. Indeed, joined column, relation duplicated.","code":"`Record relationship` %>%   inner_join(z.h.vocabularies %>%                filter(Level1==\"4. Family\"),              by=c(\"Relationship type\"=\"trm_Label\")) %>%   select(`z.h.id.Record relationship`,`Source record`,`Target record`,`Relationship type`,z.h.original) %>%   kable() Personne %>%    filter(z.h.id.Personne==\"47\") %>%    inner_join(`Record relationship`,              by=c(\"z.h.id.Personne\"=\"Source record\")) %>%   select(z.h.id.Personne,z.h.title.Personne,          `z.h.id.Record relationship`,`Relationship type`,          `Target record`,z.h.original) %>%   kable() Personne %>%    filter(z.h.id.Personne==\"47\") %>%   select(z.h.id.Personne,`Carrière & Parentèle.relationship`) %>%   kable()"},{"path":"https://alietteroux.github.io/heuristr/index.html","id":"dealing-with-temporal-spatial-and-file-fields","dir":"","previous_headings":"","what":"Dealing with temporal, spatial and file fields","title":"To make easier quantitative analysis from Heurist databases","text":"name “temporal, spatial file fields” values informed fields (“detail types” Heurist language) type “date”, “geo” “file”. Therefore, fields match value “date”, “geo” “file” column field.type dataframe z.h.tables.fields. look informed fields (empty fields), select fields matching value “empty” column field.empty z.h.tables.fields.","code":"z.h.tables.fields %>%    filter(field.type %in% c(\"date\",\"geo\",\"file\") &             field.empty==\"no empty\") %>%   select(table.name,field.DisplayName,field.type) %>%   arrange(table.name,field.type) %>%   kable()"},{"path":"https://alietteroux.github.io/heuristr/index.html","id":"temporal-fields","dir":"","previous_headings":"Dealing with temporal, spatial and file fields","what":"Temporal fields","title":"To make easier quantitative analysis from Heurist databases","text":"“Temporal” fields declined several columns according “temporal.type” value original XML file. example, dataframe Personne, values Date de naissance recorded two ways : manually, without using “calendar” widget (= “Manual Date”) using “calendar” widget (= “Simple Date”) Manually recorded dates can mixed : instance, “Printemps 1960” written “temporal” field. ’s ’s important distinguish “Manual Dates” “Simple Dates”. Columns finishing “.DAT.raw” informed “Simple Dates”. Columns describing “Simple Dates” can transformed “date vectors” without caution. want transform “date vectors” “temporal” field (even “Manual Dates”), careful : “Manual Dates” can refer “numeric” date (example : “Printemps 1960”) ; “Manual Dates” formats can different : can refer specific day, others month, others year… following lines, choose consider first day first month, day month informed. dataframe Objet, values Date de création recorded three ways : “Approximate Date”, “C14 Date” “Date range” (see ). Therefore, Date de création declined several columns : TPQ (Terminus Post-Quem),PDB (Probable Date Begin),PDE (Probable Date End) TAQ (Terminus Ante-Quem) deal “Date Range” ; BCE (Current Era),BDP (Present),DEV (Std dev), DVP (Pos Dev) DVN (Neg Dev) deal “C14 Date” ; RNG (Range) deals “Approximate Date”.","code":"# Count \"temporal.type\" Personne %>% count(`Date de naissance.temporal.type`) %>%    kable() # Colnames names(Personne)[grepl(\"^Date de naissance.+\",names(Personne))] #> [1] \"Date de naissance.temporal.raw\"  \"Date de naissance.temporal.type\" #> [3] \"Date de naissance.DAT.raw\"       \"Date de naissance.DAT.year\"      #> [5] \"Date de naissance.DAT.month\"     \"Date de naissance.DAT.day\"       #> [7] \"Date de naissance.property.DET\"  # Records Personne %>%    select(z.h.title.Personne,starts_with(\"Date de naissance\")) %>%   kable() Personne %>%    mutate(date_naiss = as.Date(`Date de naissance.DAT.raw`)) %>%   select(z.h.title.Personne,date_naiss) %>%   arrange(date_naiss) %>%   kable() Personne %>%    mutate_at(vars(`Date de naissance.DAT.month`,                  `Date de naissance.DAT.day`),             replace_na,\"01\") %>%   mutate(date_naiss = as.Date(str_c(`Date de naissance.DAT.year`,                                 `Date de naissance.DAT.month`,                                 `Date de naissance.DAT.day`,                                 sep=\"-\"))) %>%   select(z.h.title.Personne,date_naiss) %>%   arrange(date_naiss) %>%   kable() Objet %>% count(`Date de création.temporal.type`) %>%   kable() # Colnames names(Objet)[grepl(\"^Date de création.+\",names(Objet))] #>  [1] \"Date de création.temporal.raw\"  \"Date de création.temporal.type\" #>  [3] \"Date de création.DAT.raw\"       \"Date de création.DAT.year\"      #>  [5] \"Date de création.TPQ.raw\"       \"Date de création.TPQ.year\"      #>  [7] \"Date de création.PDB.raw\"       \"Date de création.PDB.year\"      #>  [9] \"Date de création.PDE.raw\"       \"Date de création.PDE.year\"      #> [11] \"Date de création.TAQ.raw\"       \"Date de création.TAQ.year\"      #> [13] \"Date de création.BCE.raw\"       \"Date de création.BCE.year\"      #> [15] \"Date de création.BPD.raw\"       \"Date de création.BPD.year\"      #> [17] \"Date de création.DEV.raw\"       \"Date de création.DEV.year\"      #> [19] \"Date de création.DVP.raw\"       \"Date de création.DVP.year\"      #> [21] \"Date de création.DVN.raw\"       \"Date de création.DVN.year\"      #> [23] \"Date de création.RNG.raw\"       \"Date de création.RNG.year\"      #> [25] \"Date de création.property.COD\"  \"Date de création.property.DET\"  #> [27] \"Date de création.property.EPF\"  \"Date de création.property.PRF\"  #> [29] \"Date de création.property.SPF\"  # Records Objet %>%    select(z.h.title.Objet,starts_with(\"Date de création\")) %>%   kable()"},{"path":"https://alietteroux.github.io/heuristr/reference/heuristr-package.html","id":null,"dir":"Reference","previous_headings":"","what":"heuristr: To make easier quantitative analysis from Heurist databases — heuristr-package","title":"heuristr: To make easier quantitative analysis from Heurist databases — heuristr-package","text":"far, package contains one function : hr_import(). function reads XML files exported Heurist (https://heuristnetwork.org/) build many dataframes 'record types' used Heurist database. Heurist 'record type' matches dataframe ; Heurist 'record' matches row dataframe. Furthermore, function builds two dataframes describing fields (type, help text, requirement, repeatability...) vocabularies.","code":""},{"path":"https://alietteroux.github.io/heuristr/reference/heuristr-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"heuristr: To make easier quantitative analysis from Heurist databases — heuristr-package","text":"Maintainer: Aliette Roux aliette.roux@univ-nantes.fr","code":""},{"path":"https://alietteroux.github.io/heuristr/reference/hr_import.html","id":null,"dir":"Reference","previous_headings":"","what":"Read data and paradata from Heurist database — hr_import","title":"Read data and paradata from Heurist database — hr_import","text":"function reads XML files exported Heurist build many dataframes 'record types' used Heurist database. Heurist 'record type' matches dataframe ; Heurist 'record' matches row dataframe. Furthermore, function builds two dataframes describing fields (type, help text, requirement, repeatability...) vocabularies.","code":""},{"path":"https://alietteroux.github.io/heuristr/reference/hr_import.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read data and paradata from Heurist database — hr_import","text":"","code":"hr_import(data.file, structure.file)"},{"path":"https://alietteroux.github.io/heuristr/reference/hr_import.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read data and paradata from Heurist database — hr_import","text":"data.file XML file exported Heurist including data (fields'values entered database) : XML file can exported Heurist via Publish menu > Export > XML (recommended option). careful : records selected Heurist session export, data theses selected records exported. structure.file XML file exported Heurist describing database structure (vocabularies, fields'caracteristics...) : XML file can exported Heurist via Design menu > Download > Structure (XML).","code":""},{"path":"https://alietteroux.github.io/heuristr/reference/hr_import.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read data and paradata from Heurist database — hr_import","text":"Several dataframes Heurist 'record type' dataframe : dataframes, row matches Heurist 'record' dataframe named \"z.h.tables.fields\" : row describes field used Heurist 'record type' (type, help text, requirement, repeatability...) dataframe named \"z.h.vocabularies\" : row matches term used Heurist vocabulary ; term joined level (ranking position vocabulary) attached parents'terms","code":""},{"path":"https://alietteroux.github.io/heuristr/reference/hr_import.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Read data and paradata from Heurist database — hr_import","text":"details : tutorial https://alietteroux.github.io/heuristr/ Github repository https://github.com/alietteroux/heuristr","code":""}]
